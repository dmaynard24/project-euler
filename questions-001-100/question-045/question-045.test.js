// Triangular, pentagonal, and hexagonal

// Problem 45
// Triangle, pentagonal, and hexagonal numbers are generated by the following formulae:

// Triangle	 	Tn=n(n+1)/2	 	1, 3, 6, 10, 15, ...
// Pentagonal	 	Pn=n(3n−1)/2	 	1, 5, 12, 22, 35, ...
// Hexagonal	 	Hn=n(2n−1)	 	1, 6, 15, 28, 45, ...
// It can be verified that T285 = P165 = H143 = 40755.

// Find the next triangle number that is also pentagonal and hexagonal.

function getTrianglePentagonHexagon() {
  let limit = 2000000000,
    triangles = getTriangles(limit),
    pentagons = getPentagons(limit),
    hexagons = getHexagons(limit),
    triangleKeys = Object.keys(triangles),
    start = triangleKeys.indexOf('40755') + 1,
    tph;

  for (let i = start; i < triangleKeys.length; i++) {
    let tkey = triangleKeys[i];
    if (pentagons[tkey] == true && hexagons[tkey] == true) {
      tph = tkey;
      break;
    }
  }

  return tph;
}

function getTriangles(limit) {
  let triangles = [],
    n = 1,
    term = 1;

  while (term < limit) {
    term = getNthTriangle(n);
    triangles[term] = true;

    n++;
  }

  return triangles;
}

function getNthTriangle(n) {
  return (n / 2) * (n + 1);
}

function getPentagons(limit) {
  let pentagons = [],
    n = 1,
    term = 1;

  while (term < limit) {
    term = getNthPentagon(n);
    pentagons[term] = true;

    n++;
  }

  return pentagons;
}

function getNthPentagon(n) {
  return (n * (3 * n - 1)) / 2;
}

function getHexagons(limit) {
  let hexagons = [],
    n = 1,
    term = 1;

  while (term < limit) {
    term = getNthHexagon(n);
    hexagons[term] = true;

    n++;
  }

  return hexagons;
}

function getNthHexagon(n) {
  return n * (2 * n - 1);
}

test('gets the next triangle number after 40755 that is also pentagonal and hexagonal to be 1533776805', () => {
  expect(getTrianglePentagonHexagon()).toBe('1533776805');
});
